function drawPolaroid(photoSrc, styleName, canvasTarget) {
  const ctx = canvasTarget.getContext("2d");
  ctx.clearRect(0, 0, canvasTarget.width, canvasTarget.height);

  const imgPhoto = new Image();
  imgPhoto.src = photoSrc;

  imgPhoto.onload = () => {
    // Fond blanc du cadre
    ctx.fillStyle = "#fff";
    ctx.fillRect(0, 0, canvasTarget.width, canvasTarget.height);

    // Marges façon Polaroïd
    const paddingTop = 20;
    const paddingSides = 20;
    const paddingBottom = 70;

    const photoWidth = canvasTarget.width - 2 * paddingSides;
    const photoHeight = canvasTarget.height - paddingTop - paddingBottom;

    // Effet ombre douce sous la photo
    ctx.save();
    ctx.shadowColor = "rgba(0, 0, 0, 0.12)";
    ctx.shadowBlur = 8;
    ctx.shadowOffsetX = 2;
    ctx.shadowOffsetY = 2;

    // Zone arrondie pour moderniser légèrement (clip path simulé)
    ctx.beginPath();
    ctx.roundRect(paddingSides, paddingTop, photoWidth, photoHeight, 8);
    ctx.clip();

    // Dessin image
    ctx.drawImage(imgPhoto, paddingSides, paddingTop, photoWidth, photoHeight);

    // Restaure le contexte pour désactiver l'ombre
    ctx.restore();

    drawPolaroidFrame(styleName, ctx, canvasTarget.width, canvasTarget.height);
  };

  imgPhoto.onerror = () => {
    ctx.fillStyle = "#eee";
    ctx.fillRect(0, 0, canvasTarget.width, canvasTarget.height);
    drawPolaroidFrame(styleName, ctx, canvasTarget.width, canvasTarget.height);
  };
}

// Ajout d'une méthode roundRect si elle n'existe pas encore
if (!CanvasRenderingContext2D.prototype.roundRect) {
  CanvasRenderingContext2D.prototype.roundRect = function (x, y, w, h, r) {
    if (typeof r === 'number') {
      r = {tl: r, tr: r, br: r, bl: r};
    } else {
      const defaultRadius = {tl: 0, tr: 0, br: 0, bl: 0};
      for (let side in defaultRadius) r[side] = r[side] || defaultRadius[side];
    }
    this.beginPath();
    this.moveTo(x + r.tl, y);
    this.lineTo(x + w - r.tr, y);
    this.quadraticCurveTo(x + w, y, x + w, y + r.tr);
    this.lineTo(x + w, y + h - r.br);
    this.quadraticCurveTo(x + w, y + h, x + w - r.br, y + h);
    this.lineTo(x + r.bl, y + h);
    this.quadraticCurveTo(x, y + h, x, y + h - r.bl);
    this.lineTo(x, y + r.tl);
    this.quadraticCurveTo(x, y, x + r.tl, y);
    this.closePath();
    return this;
  };
}
